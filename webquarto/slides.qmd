:::slides
---
titre: "Meteo Dofus Ring"
author: "Lamure Maxence, Dias Pierre, Bouland Guillaume, Festor Quentin"
date: "04/12/2023"
---
:::

:::slides
# Sommaire
:::

:::slides
# Problématique
Comment développer un site de modélisation de données sur github?
:::

:::slides
# Organisation des tâches
- Carte interactive
- Etude départementale
- Etude comparative de villes répondant à certains critères
- Lien météorologique
:::

:::slides
# Vision globale

```{python}
#| echo: false
import geopandas as gpd
import pandas as pd
import numpy as np
pd.options.mode.chained_assignment = None
import sys
sys.path.append( '../' )

# base de la carte avec les départements
sf = gpd.read_file("../bases_de_donnees/departements-version-simplifiee.geojson")
#on ne garde que les departement qui nous interessent
indexNames = sf[
    (sf["code"] != "09")
    & (sf["code"] != "11")
    & (sf["code"] != "12")
    & (sf["code"] != "30")
    & (sf["code"] != "31")
    & (sf["code"] != "32")
    & (sf["code"] != "34")
    & (sf["code"] != "46")
    & (sf["code"] != "48")
    & (sf["code"] != "65")
    & (sf["code"] != "66")
    & (sf["code"] != "81")
    & (sf["code"] != "82")
].index
sf.drop(indexNames, inplace=True)
import folium

centre = [43.716671, 2.15]
Occitanie = folium.Map(location=centre, zoom_start=6.5,tiles=None)
folium.GeoJson(
    sf[["nom", "geometry"]],
    name="Départements",
    zoom_on_click=True,
    style_function=lambda feature: {
        "fillColor": "#003322",
        "color": "grey",
        "weight": 2,
        "dashArray": "5, 5",
        "fillOpacity": 0.01,
    },
    tooltip=folium.features.GeoJsonTooltip(
        fields=["nom"],
        aliases=["Département:"],
    ),
).add_to(Occitanie)


# ajout layer pollution
from folium.plugins import HeatMap
from folium.plugins import HeatMapWithTime
from folium.plugins import GroupedLayerControl
import branca.colormap as cm

#légende

color_mapa=cm.LinearColormap(colors=['darkblue','purple','yellow'],
                             caption='intensité de concentration du polluant')

#cadre de la légende
svg_style = '<style>svg#legend {background-color: rgba(255,255,255,0.5);}</style>'

Occitanie.get_root().header.add_child(folium.Element(svg_style))
color_mapa.add_to(Occitanie)

polluant = pd.read_csv(
    "../bases_de_donnees/Mesure_mensuelle_annee.csv",
    sep=",",
    na_values="",
    low_memory=False,
)
polluants = polluant.dropna()

#moyenne des polluants sur l'année
polluants = (
    polluants.groupby(["X", "Y", "nom_poll","nom_dept"])["valeur"]
    .mean()
    .reset_index(name="valeur")
)

#gradient de couleurs adapté aux daltoniens, jaune chaud, bleu froid.
grad={
        0: "#0d0887",
        0.1: "#0d0887",
        0.2: "#0d0887",
        0.3: "#0d0887",
        0.4: "#0d0887",
        0.5: "#6a00a8",
        0.6: "#b12a90",
        0.7: "#e16462",
        0.8: "#fca636",
        0.9: "#fcce25",
        1: "#f0f921",
    }

# PM10
PM10 = polluants[(polluants["nom_poll"] == "PM10")]
heatPM10 = PM10[["Y", "X", "valeur"]].copy()
lng = heatPM10["X"].tolist()
lat = heatPM10["Y"].tolist()
val = heatPM10["valeur"].tolist()
pm10 = HeatMap(
    list(zip(lat, lng, val)),
    name="PM10",
    gradient=grad,
    radius=40,
    blur=35,
)
fpm10 = folium.FeatureGroup(name="PM10", show=True)
pm10.add_to(fpm10)

# PM2
PM2 = polluants[(polluants["nom_poll"] == "PM2.5")]

heatPM2 = PM2[["Y", "X", "valeur"]].copy()
lng = heatPM2["X"].tolist()
lat = heatPM2["Y"].tolist()
val = heatPM2["valeur"].tolist()
pm2 = HeatMap(
    list(zip(lat, lng, val)),
    name="PM2.5",
    gradient=grad,
    radius=40,
    blur=35,
)
fpm2 = folium.FeatureGroup(name="PM2", show=False)
pm2.add_to(fpm2)

# NO
NO = polluants[(polluants["nom_poll"] == "NO")]

heatNO = NO[["Y", "X", "valeur"]].copy()
lng = heatNO["X"].tolist()
lat = heatNO["Y"].tolist()
val = heatNO["valeur"].tolist()
no = HeatMap(
    list(zip(lat, lng, val)),
    name="NO",
    gradient=grad,
    radius=40,
    blur=35,
)
fno = folium.FeatureGroup(name="NO", show=False)
no.add_to(fno)

# NO2
NO2 = polluants[(polluants["nom_poll"] == "NO2")]

heatNO2 = NO2[["Y", "X", "valeur"]].copy()
lng = heatNO2["X"].tolist()
lat = heatNO2["Y"].tolist()
val = heatNO2["valeur"].tolist()
no2 = HeatMap(
    list(zip(lat, lng, val)),
    name="NO2",
    gradient=grad,
    radius=40,
    blur=35,
)
fno2 = folium.FeatureGroup(name="NO2", show=False)
no2.add_to(fno2)

# O3
O3 = polluants[(polluants["nom_poll"] == "O3")]

heatO3 = O3[["Y", "X", "valeur"]].copy()
lng = heatO3["X"].tolist()
lat = heatO3["Y"].tolist()
val = heatO3["valeur"].tolist()
o3 = HeatMap(
    list(zip(lat, lng, val)),
    name="O3",
    gradient=grad,
    radius=40,
    blur=35,
)
fo3 = folium.FeatureGroup(name="O3", show=False)
o3.add_to(fo3)

Occitanie.add_child(fpm10)
Occitanie.add_child(fpm2)
Occitanie.add_child(fno)
Occitanie.add_child(fno2)
Occitanie.add_child(fo3)

class Markero(object):
    """Classe pour faire les points folium facilement"""

    def __init__(self, lat, long, texte, popup):
        """créé un point"""
        self.lat = lat
        self.long = long
        self.texte = texte
        self.popup = popup

    def SurCarte(self,carte):
        """Met le point sur la carte"""
        folium.Marker(
        [self.lat, self.long],tooltip=self.texte, popup=self.popup, icon=folium.Icon(icon='glyphicon-th-list',color="darkpurple")
        ).add_to(carte)

Toul=Markero(43.6, 1.43333,"Toulouse","""
<p>Toulouse:<br>
500 000 habitants </p>
  """) 


Mtp=Markero(43.62505, 3.862038,"Montpellier","""
<p>Montpellier:<br>
300 000 habitants</p>
  """)

Tarbes=Markero(43.23333, 0.08333,"Tarbes","""
<p>Tarbes:<br>
Plus de 40 000 habitants</p>
  """)

Montauban=Markero(44.01667, 1.35,"Montauban","""
<p>Montauban:<br>
Plus de 60 000 habitants</p>
  """)

Pey=Markero(43.6333, 0.1833,"Peyrusse-Vieille","""
<p>Peyrusse-Vieille:<br>
65 habitants </p>
  """)

Arg=Markero(43.005028, -0.101087,"Argeles-Gazost","""
<p>Argeles-Gazost:<br>
Moins de 3000 habitants</p>
  """)

Perpi=Markero(42.683331,2.88333,"Perpignan","""
<p>Perpignan:<br>
120 000 habitants </p>
""")

Toul.SurCarte(Occitanie)
Mtp.SurCarte(Occitanie)
Tarbes.SurCarte(Occitanie)
Montauban.SurCarte(Occitanie)
Pey.SurCarte(Occitanie)
Arg.SurCarte(Occitanie)
Perpi.SurCarte(Occitanie)

folium.TileLayer("OpenStreetMap", name="Street Map").add_to(Occitanie)
folium.TileLayer("Cartodb dark_matter", name="Sombre").add_to(Occitanie)
folium.TileLayer("CartoDB Positron", name="Clair").add_to(Occitanie)

folium.LayerControl(position= 'topleft',collapsed=True,opacity=0.7).add_to(Occitanie)

GroupedLayerControl(position='bottomleft',
    groups={"Polluants": [fpm10, fpm2, fno, fno2, fo3]},
    collapsed=False
).add_to(Occitanie)


Occitanie
```

Moyenne des valeurs enregistrées entre aout 2022 et septembre 2023
\
\
Ces cartes de chaleurs prennents des valeurs de 0 à 1. On comprendra que la balise captant la concentration de polluant la plus forte se verra attribuée la plus forte température. On observe que la pollution se concentre principalement au niveau des métropoles.\
Les villes indiquées sur la carte sont celles sur lesquelles nos études se porteront.

```{python}
#| echo: false
import sys
sys.path.append( '../' )

html = """
<head>
    <link rel="stylesheet" href="styles.css">
</head>

<table>
    <tr class="tr">
        <th class="th">
            <a href=webquarto/Departements/constatations.qmd><img src="../images/etude.svg" title="Etude Départementale" width="110" height="110"></a> <a href=webquarto/villes.qmd><img src="../images/city.svg" title="Comparatif des villes" width="150" height="150"></a> <a href=webquarto/meteo.qmd><img src="../images/weather.svg" title="Influence de la météo sur la pollution" width="130" height="130"></a> <a href=webquarto/about.qmd><img src="../images/mask.svg" title="En savoir plus sur les polluants" width="170" height="170"></a> 
        </th>
    </tr>
</table>
"""

display(html)
```
:::

:::slides

```{python}
#| echo: true
#| include: false
import geopandas as gpd
import pandas as pd
import numpy as np
pd.options.mode.chained_assignment = None
import sys
sys.path.append( '../' )

# base de la carte avec les départements
sf = gpd.read_file("../bases_de_donnees/departements-version-simplifiee.geojson")
#on ne garde que les departement qui nous interessent
indexNames = sf[
    (sf["code"] != "09")
    & (sf["code"] != "11")
    & (sf["code"] != "12")
    & (sf["code"] != "30")
    & (sf["code"] != "31")
    & (sf["code"] != "32")
    & (sf["code"] != "34")
    & (sf["code"] != "46")
    & (sf["code"] != "48")
    & (sf["code"] != "65")
    & (sf["code"] != "66")
    & (sf["code"] != "81")
    & (sf["code"] != "82")
].index
sf.drop(indexNames, inplace=True)
import folium

centre = [43.716671, 2.15]
Occitanie = folium.Map(location=centre, zoom_start=6.5,tiles=None)
folium.GeoJson(
    sf[["nom", "geometry"]],
    name="Départements",
    zoom_on_click=True,
    style_function=lambda feature: {
        "fillColor": "#003322",
        "color": "grey",
        "weight": 2,
        "dashArray": "5, 5",
        "fillOpacity": 0.01,
    },
    tooltip=folium.features.GeoJsonTooltip(
        fields=["nom"],
        aliases=["Département:"],
    ),
).add_to(Occitanie)


# ajout layer pollution
from folium.plugins import HeatMap
from folium.plugins import HeatMapWithTime
from folium.plugins import GroupedLayerControl
import branca.colormap as cm

#légende

color_mapa=cm.LinearColormap(colors=['darkblue','purple','yellow'],
                             caption='intensité de concentration du polluant')

#cadre de la légende
svg_style = '<style>svg#legend {background-color: rgba(255,255,255,0.5);}</style>'

Occitanie.get_root().header.add_child(folium.Element(svg_style))
color_mapa.add_to(Occitanie)

polluant = pd.read_csv(
    "../bases_de_donnees/Mesure_mensuelle_annee.csv",
    sep=",",
    na_values="",
    low_memory=False,
)
polluants = polluant.dropna()

#moyenne des polluants sur l'année
polluants = (
    polluants.groupby(["X", "Y", "nom_poll","nom_dept"])["valeur"]
    .mean()
    .reset_index(name="valeur")
)

#gradient de couleurs adapté aux daltoniens, jaune chaud, bleu froid.
grad={
        0: "#0d0887",
        0.1: "#0d0887",
        0.2: "#0d0887",
        0.3: "#0d0887",
        0.4: "#0d0887",
        0.5: "#6a00a8",
        0.6: "#b12a90",
        0.7: "#e16462",
        0.8: "#fca636",
        0.9: "#fcce25",
        1: "#f0f921",
    }

# PM10
PM10 = polluants[(polluants["nom_poll"] == "PM10")]
heatPM10 = PM10[["Y", "X", "valeur"]].copy()
lng = heatPM10["X"].tolist()
lat = heatPM10["Y"].tolist()
val = heatPM10["valeur"].tolist()
pm10 = HeatMap(
    list(zip(lat, lng, val)),
    name="PM10",
    gradient=grad,
    radius=40,
    blur=35,
)
fpm10 = folium.FeatureGroup(name="PM10", show=True)
pm10.add_to(fpm10)

# PM2
PM2 = polluants[(polluants["nom_poll"] == "PM2.5")]

heatPM2 = PM2[["Y", "X", "valeur"]].copy()
lng = heatPM2["X"].tolist()
lat = heatPM2["Y"].tolist()
val = heatPM2["valeur"].tolist()
pm2 = HeatMap(
    list(zip(lat, lng, val)),
    name="PM2.5",
    gradient=grad,
    radius=40,
    blur=35,
)
fpm2 = folium.FeatureGroup(name="PM2", show=False)
pm2.add_to(fpm2)

# NO
NO = polluants[(polluants["nom_poll"] == "NO")]

heatNO = NO[["Y", "X", "valeur"]].copy()
lng = heatNO["X"].tolist()
lat = heatNO["Y"].tolist()
val = heatNO["valeur"].tolist()
no = HeatMap(
    list(zip(lat, lng, val)),
    name="NO",
    gradient=grad,
    radius=40,
    blur=35,
)
fno = folium.FeatureGroup(name="NO", show=False)
no.add_to(fno)

# NO2
NO2 = polluants[(polluants["nom_poll"] == "NO2")]

heatNO2 = NO2[["Y", "X", "valeur"]].copy()
lng = heatNO2["X"].tolist()
lat = heatNO2["Y"].tolist()
val = heatNO2["valeur"].tolist()
no2 = HeatMap(
    list(zip(lat, lng, val)),
    name="NO2",
    gradient=grad,
    radius=40,
    blur=35,
)
fno2 = folium.FeatureGroup(name="NO2", show=False)
no2.add_to(fno2)

# O3
O3 = polluants[(polluants["nom_poll"] == "O3")]

heatO3 = O3[["Y", "X", "valeur"]].copy()
lng = heatO3["X"].tolist()
lat = heatO3["Y"].tolist()
val = heatO3["valeur"].tolist()
o3 = HeatMap(
    list(zip(lat, lng, val)),
    name="O3",
    gradient=grad,
    radius=40,
    blur=35,
)
fo3 = folium.FeatureGroup(name="O3", show=False)
o3.add_to(fo3)

Occitanie.add_child(fpm10)
Occitanie.add_child(fpm2)
Occitanie.add_child(fno)
Occitanie.add_child(fno2)
Occitanie.add_child(fo3)

class Markero(object):
    """Classe pour faire les points folium facilement"""

    def __init__(self, lat, long, texte, popup):
        """créé un point"""
        self.lat = lat
        self.long = long
        self.texte = texte
        self.popup = popup

    def SurCarte(self,carte):
        """Met le point sur la carte"""
        folium.Marker(
        [self.lat, self.long],tooltip=self.texte, popup=self.popup, icon=folium.Icon(icon='glyphicon-th-list',color="darkpurple")
        ).add_to(carte)

Toul=Markero(43.6, 1.43333,"Toulouse","""
<p>Toulouse:<br>
500 000 habitants </p>
  """) 


Mtp=Markero(43.62505, 3.862038,"Montpellier","""
<p>Montpellier:<br>
300 000 habitants</p>
  """)

Tarbes=Markero(43.23333, 0.08333,"Tarbes","""
<p>Tarbes:<br>
Plus de 40 000 habitants</p>
  """)

Montauban=Markero(44.01667, 1.35,"Montauban","""
<p>Montauban:<br>
Plus de 60 000 habitants</p>
  """)

Pey=Markero(43.6333, 0.1833,"Peyrusse-Vieille","""
<p>Peyrusse-Vieille:<br>
65 habitants </p>
  """)

Arg=Markero(43.005028, -0.101087,"Argeles-Gazost","""
<p>Argeles-Gazost:<br>
Moins de 3000 habitants</p>
  """)

Perpi=Markero(42.683331,2.88333,"Perpignan","""
<p>Perpignan:<br>
120 000 habitants </p>
""")

Toul.SurCarte(Occitanie)
Mtp.SurCarte(Occitanie)
Tarbes.SurCarte(Occitanie)
Montauban.SurCarte(Occitanie)
Pey.SurCarte(Occitanie)
Arg.SurCarte(Occitanie)
Perpi.SurCarte(Occitanie)

folium.TileLayer("OpenStreetMap", name="Street Map").add_to(Occitanie)
folium.TileLayer("Cartodb dark_matter", name="Sombre").add_to(Occitanie)
folium.TileLayer("CartoDB Positron", name="Clair").add_to(Occitanie)

folium.LayerControl(position= 'topleft',collapsed=True,opacity=0.7).add_to(Occitanie)

GroupedLayerControl(position='bottomleft',
    groups={"Polluants": [fpm10, fpm2, fno, fno2, fo3]},
    collapsed=False
).add_to(Occitanie)


Occitanie
```
:::

:::slides
# Etude de la pollution dans chaque département

```{python}
#| echo: false
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import warnings
import sys
sys.path.append( '../' )

# Désactiver temporairement les avertissements spécifiques
warnings.filterwarnings("ignore", category=UserWarning, message="Converting to PeriodArray/Index representation will drop timezone information.")

pd.options.mode.chained_assignment = None
# Charger les données
bdd1 = pd.read_csv("../bases_de_donnees/Mesure_mensuelle_annee.csv")
bdd1['valeur'].fillna(0, inplace=True)

# Liste des polluants à afficher
polluants = ['NO', 'NOX', 'O3', 'PM10', 'NO2']

# Plages des ordonnées pour chaque polluant
ordonnee_ranges = {'NO': [0, 85], 'NOX': [0, 180], 'O3': [0, 90], 'PM10': [0, 45], 'NO2': [0, 70]}

# Boucle à travers les polluants pour créer les graphiques
for polluant in polluants:
    # Filtrer les données pour le polluant et le département HAUTE-GARONNE
    filtered_data = bdd1[(bdd1['nom_dept'] == 'HAUTE-GARONNE') & (bdd1['nom_poll'] == polluant)]
    filtered_data = filtered_data.sort_values(by='date_debut')

    # Afficher le titre entre chaque graphique
    from IPython.display import display, Markdown
    display(Markdown(f"## Evolution mensuelle du {polluant}"))


    # Convertir la colonne de dates au format aaaa/mm
    filtered_data['date_debut'] = pd.to_datetime(filtered_data['date_debut']).dt.to_period('M').astype(str)

    # Créer un graphique interactif avec Plotly Express
    fig = px.scatter(
        filtered_data, x='date_debut', y='valeur',
        color='nom_station', size='valeur', hover_name='date_debut',
        title=f'Évolution de la pollution {polluant} en Haute-Garonne',
        labels={'valeur': f'Valeur {polluant} (ug.m-3)', 'date_debut': 'Année'}
    )

    # Ajouter des lignes reliant les points pour chaque station
    for nom_station in filtered_data['nom_station'].unique():
        trace_data = filtered_data[filtered_data['nom_station'] == nom_station]
        fig.add_trace(go.Scatter(
            x=trace_data['date_debut'],
            y=trace_data['valeur'],
            mode='lines',  # Utilisez 'lines' pour ajouter des lignes reliant les points
            showlegend=False
        ))

    # Mise en forme et personnalisation
    fig.update_layout(
        title_text=f'Évolution de la pollution {polluant} en Haute-Garonne',
        title_x=0.5,  # Centrer le titre
        xaxis_title="Année",
        yaxis_title=f'Valeur {polluant} (ug.m-3)',
        xaxis_tickformat="%Y/%m",  # Format de l'axe des x
        legend=dict(orientation="h", yanchor="bottom", y=-0.5, xanchor="center", x=0.5, traceorder='reversed'),
        margin=dict(l=10, r=10, t=70, b=10),  # Ajustements des marges
        paper_bgcolor='rgba(100,100,100,0)',  # Couleur de contour de graphique 
        plot_bgcolor='rgba(100,100,100,0)',   # Couleur du fond du graphique
        yaxis=dict(range=ordonnee_ranges[polluant]),  # Ajuster l'axe des ordonnées
        font=dict(color='Grey')
    )
    #couleur grille
    fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='LightGrey')
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='LightGrey')
    # Afficher le graphique
    fig.show()

```
:::

:::slides
```{python,eval=FALSE,echo=TRUE}
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import warnings
import sys
sys.path.append( '../' )

# Désactiver temporairement les avertissements spécifiques
warnings.filterwarnings("ignore", category=UserWarning, message="Converting to PeriodArray/Index representation will drop timezone information.")

pd.options.mode.chained_assignment = None
# Charger les données
bdd1 = pd.read_csv("../bases_de_donnees/Mesure_mensuelle_annee.csv")
bdd1['valeur'].fillna(0, inplace=True)

# Liste des polluants à afficher
polluants = ['NO', 'NOX', 'O3', 'PM10', 'NO2']

# Plages des ordonnées pour chaque polluant
ordonnee_ranges = {'NO': [0, 85], 'NOX': [0, 180], 'O3': [0, 90], 'PM10': [0, 45], 'NO2': [0, 70]}

# Boucle à travers les polluants pour créer les graphiques
for polluant in polluants:
    # Filtrer les données pour le polluant et le département HAUTE-GARONNE
    filtered_data = bdd1[(bdd1['nom_dept'] == 'HAUTE-GARONNE') & (bdd1['nom_poll'] == polluant)]
    filtered_data = filtered_data.sort_values(by='date_debut')

    # Afficher le titre entre chaque graphique
    from IPython.display import display, Markdown
    display(Markdown(f"## Evolution mensuelle du {polluant}"))


    # Convertir la colonne de dates au format aaaa/mm
    filtered_data['date_debut'] = pd.to_datetime(filtered_data['date_debut']).dt.to_period('M').astype(str)

    # Créer un graphique interactif avec Plotly Express
    fig = px.scatter(
        filtered_data, x='date_debut', y='valeur',
        color='nom_station', size='valeur', hover_name='date_debut',
        title=f'Évolution de la pollution {polluant} en Haute-Garonne',
        labels={'valeur': f'Valeur {polluant} (ug.m-3)', 'date_debut': 'Année'}
    )

    # Ajouter des lignes reliant les points pour chaque station
    for nom_station in filtered_data['nom_station'].unique():
        trace_data = filtered_data[filtered_data['nom_station'] == nom_station]
        fig.add_trace(go.Scatter(
            x=trace_data['date_debut'],
            y=trace_data['valeur'],
            mode='lines',  # Utilisez 'lines' pour ajouter des lignes reliant les points
            showlegend=False
        ))

    # Mise en forme et personnalisation
    fig.update_layout(
        title_text=f'Évolution de la pollution {polluant} en Haute-Garonne',
        title_x=0.5,  # Centrer le titre
        xaxis_title="Année",
        yaxis_title=f'Valeur {polluant} (ug.m-3)',
        xaxis_tickformat="%Y/%m",  # Format de l'axe des x
        legend=dict(orientation="h", yanchor="bottom", y=-0.5, xanchor="center", x=0.5, traceorder='reversed'),
        margin=dict(l=10, r=10, t=70, b=10),  # Ajustements des marges
        paper_bgcolor='rgba(100,100,100,0)',  # Couleur de contour de graphique 
        plot_bgcolor='rgba(100,100,100,0)',   # Couleur du fond du graphique
        yaxis=dict(range=ordonnee_ranges[polluant]),  # Ajuster l'axe des ordonnées
        font=dict(color='Grey')
    )
    #couleur grille
    fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='LightGrey')
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='LightGrey')
    # Afficher le graphique
    fig.show()

```
:::

:::slides
# Etude de l'influence de la population
:::

:::slides
# Problèmes rencontrés
```{python,eval=FALSE,echo=TRUE}
# mettre mon code dash 
```
:::

:::slides
# Liens pollutions et météorologie
```{python}
#| echo: true
#| eval: false
#Liste des polluants
polluants_tous = ['PM10', 'O3', 'NOX', 'NO2', 'PM2.5', 'NO']
mois_mapping = {"01": "Janvier", "02": "Février", "03": "Mars", "04": "Avril", "05": "Mai", "06": "Juin","07": "Juillet", "08": "Août", "09": "Septembre", "10": "Octobre", "11": "Novembre", "12": "Décembre"}

def resultats(polluants_tous, polluants):
    resultat = []
    for polluant in polluants_tous:
        # Moyenne des valeurs de chaque polluant par mois
        df_polluant = (
            polluants[polluants["nom_poll"] == polluant]
            .groupby(date)["valeur"]
            .mean()
            .reset_index()
        )
        df_polluant["nom"] = polluant
        df_polluant[date] = df_polluant[date].replace(mapping)
        resultat.append(df_polluant)
    return resultat
```
:::

:::slides
```{python}
#| echo: true
#| eval: false
# Paramétrer le graphique polaire
fig_polar = px.line_polar(
    resultat,
    r="valeur",
    theta=date,
    color="nom",
    line_close=True,
    range_r=[0, max(resultat["valeur"])],
    start_angle=90,
    color_discrete_sequence=['orange', 'green', 'purple', 'red', 'blue', 'grey'],
    title='Concentration moyenne mensuelle des polluants (en µg.m⁻³)'
)

def graphique_polar(fig):
    """Mise en page d'un graphique polaire"""
    fig.update_layout(
        font_size=15,
        font_color="grey",
        showlegend=True,
        polar=dict(
            bgcolor="rgba(223, 223, 223,0)",
            angularaxis=dict(linewidth=3, showline=True, linecolor="grey"),
            radialaxis=dict(
                showline=True,
                linewidth=2,
                gridcolor="rgba(100, 100, 100,0.5)",
                gridwidth=2,
            ),
            angularaxis_gridcolor="rgba(100, 100, 100,0.5)",
            radialaxis_linecolor="rgb(100, 100, 100)",
            radialaxis_color="grey",
        ),
        paper_bgcolor="rgba(230, 230, 230,0)",  # Couleur de contour de graphique
        plot_bgcolor="rgba(230, 230, 230,0)",  # Couleur du fond du graphique
    )
```
:::

:::slides
```{python}
#| echo: false
#| eval: true
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import sys
sys.path.append( '../' )
from modules import meteo as md

"""CONCENTRATION POLLUTION"""

"""
DONNEES
"""

# Importer les valeurs
polluants = pd.read_csv("../bases_de_donnees/donnees_polluants_2022_2023_Toulouse.csv", sep=",", na_values="", low_memory=False)

# Extraire le mois de chaque date
polluants['Date'] = pd.to_datetime(polluants['date_debut'])

# Extraire les lignes correspondant au mois de mars
polluants_mars = polluants[polluants['Date'].dt.month == 3].copy()

# Définir les polluants
polluants_tous = ['PM10', 'O3', 'NOX', 'NO2', 'PM2.5', 'NO']

# Définir les couleurs correspondantes
couleur = ['orange', 'green','purple', 'red', 'blue', 'grey']

# Dictionnaire de correspondance entre les anciens et les nouveaux noms des mois/jours
mois_mapping = {"01": "Janvier", "02": "Février", "03": "Mars", "04": "Avril", "05": "Mai", "06": "Juin", "07": "Juillet", "08": "Août", "09": "Septembre", "10": "Octobre", "11": "Novembre", "12": "Décembre"}
jours_mapping = {"Monday": "Lundi", "Tuesday": "Mardi", "Wednesday": "Mercredi", "Thursday": "Jeudi", "Friday": "Vendredi", "Saturday": "Samedi", "Sunday": "Dimanche"}

def concentration(date, format, mapping, titre, temps):
    """Traitement des polluants exclusivement"""

    """
    DONNEES
    """

    # Formatage des dates
    polluants[date] = polluants['Date'].dt.strftime(format)

    # Moyenne des valeurs des polluants
    resultat = md.resultats(date, polluants_tous, polluants, mapping)
    
    # Récupérer les DataFrames individuels
    PM, O, NOX, NOO, PMM, NO = resultat

    # Concaténer tous les polluants dans resultat
    resultat = pd.concat([NOX, NOO, NO, O, PM, PMM], ignore_index=True)


    """
    GRAPHIQUE
    """
    
    # Paramétrer le graphique polaire
    fig_polar = px.line_polar(
        resultat,
        r="valeur",
        theta=date,
        color="nom",
        line_close=True,
        range_r=[0, max(resultat["valeur"])],
        start_angle=90,
        color_discrete_sequence=couleur,
        title=titre
    )
    md.graphique_polar(fig_polar)

    # Afficher le graphique polaire
    fig_polar.show()

# Graphique mois
concentration('Mois', '%m', mois_mapping, 'Concentration moyenne mensuelle des polluants (en µg.m⁻³)', 'Temps (mois)')
```
:::

:::slides
```{python}
#| echo: true
#| eval: false
# Formater les dates
donnees["Date"] = donnees["Date"].apply(lambda x: x.split("T")[0])
donnees['Date'] = pd.to_datetime(donnees['Date'])

# Extraire les lignes correspondant au mois de mars
# Créer une copie pour éviter les problèmes de vue
donnees_mars = donnees[donnees['Date'].dt.month == 3].copy()

# Renommer colonnes
donnees_mars.rename(
    columns={"Vitesse du vent moyen 10 mn": "valeur"}, inplace=True)

# Vitesse moyenne du vent chaque jour de la période
vent_moy = donnees_mars.groupby('Date')['valeur'].mean().reset_index()

# Conversion en km/h
vent_moy['valeur'] = vent_moy['valeur'].multiply(3.6)
```
:::

:::slides
```{python}
#| echo: true
#| eval: false
def moy(var, nom1, nom2, date):
    """Moyenne des valeurs des polluants par jour"""
    return var[(var[nom1] == nom2)].groupby(date)["valeur"].mean().reset_index()

fig = go.Figure()

def graphique_axe(fig, titre, yaxis2_title):
    """Mise en page d'un graphique cartésien avec 2 axes y"""
    fig.update_layout(
        title=titre,
        xaxis=dict(title="Temps (jours)"),  # Abscisse
        yaxis=dict(title="Concentration (µg.m⁻³)", side="left", position=0),  # Ordonnée
        yaxis2=dict(
            title=yaxis2_title, overlaying="y", side="right", position=1
        ),  # Deuxième ordonnée
        font_size=15,
        showlegend=True,
        paper_bgcolor="rgba(230, 230, 230,0)",  # Couleur de contour de graphique
        plot_bgcolor="rgba(100,100,100,0)",  # Couleur du fond du graphique
        font=dict(color="Grey"),
        legend=dict(x=1.1, y=1),
    )
    fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor="LightGrey")
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor="LightGrey")

def trace(df, color, name, date):
    """Ajout courbe sur un graphique cartésien"""
    return go.Scatter(x=df[date], y=df["valeur"], mode="lines", line=dict(width=2, color=color), name=name)
```
:::

:::slides
```{python}
#| echo: false
#| eval: true
"""LIEN VENTS/POLLUANTS"""

"""
DONNEES
"""

# Importer les valeurs
donnees = pd.read_csv("../bases_de_donnees/donnees_meteo_2022_2023_Toulouse.csv",
                      sep=";", na_values="", low_memory=False)

# Formater les dates
donnees["Date"] = donnees["Date"].apply(lambda x: x.split("T")[0])
donnees['Date'] = pd.to_datetime(donnees['Date'])

# Extraire les lignes correspondant au mois de mars
# Créer une copie pour éviter les problèmes de vue
donnees_mars = donnees[donnees['Date'].dt.month == 3].copy()

# Renommer colonnes
donnees.rename(columns={'Température': "valeur"}, inplace=True)
donnees_mars.rename(
    columns={"Vitesse du vent moyen 10 mn": "valeur"}, inplace=True)

"""
VENT
"""

# Vitesse moyenne du vent chaque jour de la période
vent_moy = donnees_mars.groupby('Date')['valeur'].mean().reset_index()

# Conversion en km/h
vent_moy['valeur'] = vent_moy['valeur'].multiply(3.6)


"""
POLLUANTS
"""

# Moyenne des valeurs des polluants par jour
NOX = md.moy(polluants_mars, 'nom_poll', 'NOX', 'Date')
NOO = md.moy(polluants_mars, 'nom_poll', 'NO2', 'Date')
NO = md.moy(polluants_mars, 'nom_poll', 'NO', 'Date')
O = md.moy(polluants_mars, 'nom_poll', 'O3', 'Date')

"""
GRAPHIQUE
"""

# Ajouter la trace pour le vecteur vent_moy sur le deuxième axe Y
trace_vent_moy = go.Scatter(x=vent_moy["Date"], y=vent_moy["valeur"], mode='lines', line=dict(
    width=2, color='pink'), name='Vent', yaxis='y2')

# Créer la figure
fig = go.Figure([trace_vent_moy])

# Ajouter les courbes des polluants
fig.add_trace(md.trace(NOX, 'orange', 'NOx', "Date"))
fig.add_trace(md.trace(NOO, 'green', 'NO₂', "Date"))
fig.add_trace(md.trace(NO, 'purple', 'NO', "Date"))
fig.add_trace(md.trace(O, 'red', 'O₃', "Date"))

md.graphique_axe(
    fig, "Vitesse du vent et émissions d'oxydes d'azote (mars 2023)", 'Vitesse (km.h⁻¹)')

# Afficher le graphique
fig.show()
```
:::

# Tests pythons

:::slides
```{python}
#| echo: true
#| eval: false
from modules.meteo import trace, resultats, moy

def test_trace():
    df = pd.DataFrame({'date': ['2023-01-01', '2023-01-02'], 'valeur': [10, 20]})
    courbe = trace(df, 'blue', 'Courbe', 'date')
    # Ajouter des assertions pour vérifier que la courbe a été correctement créée
    assert courbe.x.tolist() == ['2023-01-01', '2023-01-02']
    assert courbe.y.tolist() == [10, 20]

def test_resultats():
    date = 'Jour'
    polluants_tous = ['Polluant1', 'Polluant2']
    polluants = pd.DataFrame({'Jour': ['2023-01-01', '2023-01-01', '2023-01-02', '2023-01-02'],
                              'valeur': [10, 15, 20, 25],
                              'nom_poll': ['Polluant1', 'Polluant2', 'Polluant1', 'Polluant2']})
    mapping = {'2023-01-01': 'Lundi', '2023-01-02': 'Mardi'}
    result = resultats(date, polluants_tous, polluants, mapping)
    assert result[0].shape == (2, 3)  # Vérifier la forme du DataFrame résultant

def test_moy():
    var = pd.DataFrame({'date': ['2023-01-01', '2023-01-01', '2023-01-02', '2023-01-02'],
                        'valeur': [10, 15, 20, 25],
                        'nom1': ['Polluant1', 'Polluant2', 'Polluant1', 'Polluant2']})
    resultat = moy(var, 'nom1', 'Polluant1', 'date')
    assert resultat.shape == (2, 2)  # Vérifier la forme du DataFrame résultant
```
:::

:::slides
```{python}
#| echo: true
#| eval: false
def test_markero_sur_carte():
    # Créer une carte Folium
    carte = folium.Map(location=[0, 0], zoom_start=5)

    # Créer une instance de la classe Markero
    marqueur = Markero(100, -20, "nom", "popup")

    # Appeler la méthode SurCarte pour placer le marqueur sur la carte
    marqueur.SurCarte(carte)

    # Vérifier que le marqueur a été ajouté à la carte
    children = list(carte._children.values())  # Convertir en liste

    # Vérifier que les propriétés du marqueur sont correctes
    marqueur_map_child = children[1]
    assert marqueur_map_child.location == [100,-20]
```
:::